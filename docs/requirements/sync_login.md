# 同期/ログイン要件メモ

## 目的
- デバイス間同期のためのログイン機能を定義する
- MVPに必要な範囲と、後回しにする範囲を明確にする

## 決定事項（更新していく）
- デモ版はCloudKit（iCloud）を同期基盤として採用する。
- 衝突（conflict）は「最終更新が勝つ（LWW）＋負けた内容はコピー/スナップショットとして残す」で扱う。
- アプリ内ログインはSign in with Appleを必須とする。
- 「アプリ内ログイン（Sign in with Apple）」と「端末のiCloudサインイン（設定）」は別物として扱い、未充足の要件があればブロッキング画面で誘導する。
- iCloudが利用可能な場合のみ同期を有効化する。
- iCloudが利用不可のうち、端末がiCloudアカウントに未サインインの場合はアプリ利用不可（ブロッキング画面→設定誘導）。
- 上記以外の理由でiCloud/CloudKitが利用不可の場合はローカル限定で動作し、「同期機能が使えない」旨と設定への誘導を提示する。

## 未決定事項（優先順で埋める）
1) ログイン体験（決定）
   - 決定: Sign in with Appleでログイン（必須）
2) 同期対象の範囲
   - 候補: 本文/アウトライン/プロット/キャラクター/情報/スナップショット/履歴メタデータ
3) オフライン前提
   - 候補: 完全オフライン可 / 作成は可・同期は後 / オンライン必須
4) 競合時の扱い
   - 決定: LWW＋コピー/スナップショット保存
5) 同期タイミング
   - 候補: 自動（バックグラウンド）/ 手動ボタン / 保存時のみ
6) セキュリティ/プライバシー
   - 候補: 端末暗号化 / サーバー暗号化 / 退会時削除 / 端末紛失時の扱い
7) ログイン/ログアウト体験
   - 決定: 初回起動で必須（Sign in with Apple）
   - 未決定: ログアウト時のローカル保持（保持する/消す/選べる）

## 想定ユーザーフロー（仮）
1. 初回起動 → 同期の説明 → ログイン（必須）
2. 作業 → ローカル保存
3. 同期条件を満たしたらサーバーへアップロード
4. 別端末でログイン → 同期完了 → 作品一覧に表示

## 仕様化のためのメモ
- 同期対象に「スナップショット」を含めるかは重要（Git機能と直結）
- 競合をどう扱うかでUI/データ構造が変わる
- 一般にCloudKit採用時は「ユーザーのiCloudアカウント」が実質のログインになる（ただし本アプリではSign in with Appleも必須とする）
- 今回は「アプリ内ログイン（Sign in with Apple）」と「同期基盤（CloudKit）」を併用する前提（iCloud利用不可時はローカルにフォールバック）。

## iCloud/CloudKitが「利用不可」になるケースと挙動（案）
- 未ログイン（端末がiCloudアカウントにサインインしていない）: アプリ利用不可。ポップアップで「iCloudにサインインしてください」→設定に誘導。
- 無効化（iCloud/CloudKitが使えない状態）: 同期不可。ポップアップで「iCloudを有効にしてください」→設定に誘導。動作はローカル限定。
- 容量不足（クォータ超過）: 同期処理は失敗するのが基本で「足りてる分だけ保存」は期待しない（部分保存で整合性が崩れるため）。動作はローカル限定＋未同期表示＋容量確保後に再同期。
- 制限（スクリーンタイム/MDM等のrestricted）: 同期不可。理由を表示してローカル限定（ユーザー側で解除が必要）。
- 一時的な問題（ネットワーク/サーバー一時不可など）: ローカルに保存し続け、バックグラウンドや手動でリトライ。

## 同期失敗時の基本方針（案）
- 先にローカルへ確実に保存し、同期は「後追い」で試みる。
- 未同期状態をUIで分かるようにする（例: 作品一覧に「未同期」バッジ）。
- 再同期の導線を用意（自動リトライ＋手動「再同期」）。

## 用語の説明（初心者向け）
- AuthenticationServices: iOSが標準で持っている「サインイン機能の部品」。アプリにログイン画面を出し、Apple IDで認証した結果（トークン）を返してくれる。
- Apple専用基盤: Appleが提供するクラウド/同期の仕組み（例: CloudKit, iCloud）。AppleのSDKで使う前提で、他OSやVSCode拡張から直接使いにくい。
- 認証と保存は別物: Sign in with Appleは「ログイン方法」、CloudKitは「保存先」。ログインはApple、保存は別サービスという組み合わせも可能。
- iCloudアカウント: iCloudにサインインするためのAppleのアカウント。実体はApple ID（最近は「Apple Account」と表記されることもある）で、同じアカウント概念。
- iCloudサインイン（このメモでの意味）: 端末が既にiCloudにサインインしている状態（設定アプリのApple Account/Apple ID）。CloudKitはこのiCloudアカウントを「ユーザー識別」として使う。

## よくある誤解
- AuthenticationServicesを使うとCloudKit必須になる → ならない。ログイン方法と保存先は別。
- Appleログイン＝Apple専用保存 → ちがう。Supabase等の汎用バックエンドに保存しても問題ない。

## Sign in with Apple の仕組み（概要）
- AppleのOAuth 2.0 / OpenID Connectを使う認証方式。
- iOSでは `AuthenticationServices`（`ASAuthorizationAppleIDProvider`）でログインし、
  `identityToken`（JWT）と `authorizationCode` を取得する。
- バックエンドはAppleの公開鍵でJWTを検証し、`sub` をユーザーIDとして扱う。
- Web/VSCode拡張ではブラウザ認証フロー（Apple JS / OAuth）を使う前提。

## VSCode拡張との同期を考慮した場合の論点
- CloudKitなどApple専用基盤はVSCodeから利用しづらく、相性が悪い。
- どのクライアントからでも呼べるAPI（REST/GraphQL等）が必要になる。
- 認証はAppleログインのWebフローが必要（ブラウザで認証→トークン取得）。

## バックエンド変更の可能性とコスト
- ベンダー固有機能（CloudKit固有のデータモデルやリアルタイム同期）に依存すると移行コストが高い。
- 「同期API」と「ローカル保存」を分離して設計すると、将来の移行が楽になる。
- まずは最小の同期要件を決め、後から拡張できる形にしておくのが安全。

## VSCode拡張での Sign in with Apple（概要）
- iOSの `AuthenticationServices` は使えないため、ブラウザでのOAuthログインになる。
- 典型フロー:
  1) 拡張がブラウザでログインURLを開く
  2) Appleのログイン画面で認証
  3) AppleがリダイレクトURIへ戻す（vscode:// か localhost など）
  4) 拡張またはバックエンドが認証コードを受け取る
  5) バックエンドでトークン交換（Appleの秘密鍵が必要）
  6) 拡張はセッション/トークンを受け取り保存
- Appleの認証は「コード交換」に秘密鍵が必要なため、拡張単体では完結しない（サーバー側が必要）。
- Supabase/Auth0等を使う場合は、拡張は「ログイン開始→完了を受け取る」だけで済む。

## 補足: 本番で全プラットフォーム対応する場合
- CloudKitはApple寄りのため、Android/Web/VSCodeを本気でやるなら別基盤が必要になる可能性が高い。
- デモでCloudKitを学びつつ、本番の同期基盤（Supabase/Firebase/自前API等）は別途選定する。
